library(tidyverse)
# log predictive density,
dnorm(x = y, mean = theta_1, sd = 1)
library(tidyverse)
y <- 4
set.seed(30071999)
theta_1 <- rnorm(10000, mean = 0, sd = 1)
theta_2 <- rnorm(10000, mean = 10, sd = 3)
theta_3 <- rnorm(10000, mean = 10, sd = 6)
pred_1 <- rnorm(10000, mean = theta_1, sd = 1)
pred_2 <- rnorm(10000, mean = theta_2, sd = 1)
pred_3 <- rnorm(10000, mean = theta_3, sd = 1)
distributions <- data.frame(theta = c(theta_1,theta_2,theta_3), model = rep(c("1","2","3"), each = 10000),
y_pred = c(pred_1,pred_2,pred_3))
# Plot posterior distributions for \theta ~ N(?, ?)
distributions %>%
ggplot() +
geom_density(mapping = aes(x = theta, fill = model), alpha = 0.5) +
geom_vline(xintercept = 4, color = "red")
# Plot predictive distributions for y ~ N(\theta, 1)
distributions %>%
ggplot() +
geom_density(mapping = aes(x = y_pred, fill = model), alpha = 0.5) +
geom_vline(xintercept = 4, color = "red")
# MSE for models 1, 2, & 3
(y - mean(pred_1))^2
(y - mean(pred_2))^2
(y - mean(pred_3))^2
# Weighted MSE for models 1, 2, & 3
(y - mean(pred_1))^2 / var(pred_1)
(y - mean(pred_2))^2 / var(pred_2)
(y - mean(pred_3))^2 / var(pred_3)
# Model that disregards bias in posterior estimator is vague
theta_4 <- rnorm(10000, mean = 100, sd = 100)
pred_4 <- rnorm(10000, mean = theta_4, sd = 1)
(y - mean(pred_4))^2 / var(pred_4)
# log predictive density,
dnorm(x = y, mean = theta_1, sd = 1)
# log predictive density
# find posterior mean of density of future y observation varied by the posterior \theta
mean(dnorm(x = y, mean = theta_1, sd = 1)) # model 1
# log predictive density
# find posterior mean of density of future y observation varied by the posterior \theta then log it
log(mean(dnorm(x = y, mean = theta_1, sd = 1))) # model 1
log(mean(dnorm(x = y, mean = theta_1, sd = 1))) # model 1
log(mean(dnorm(x = y, mean = theta_2, sd = 1))) # model 2
log(mean(dnorm(x = y, mean = theta_3, sd = 1))) # model 2
# R scales the MAD.  Use constant = 1 to get raw
mad(c(1,2,3))
mad(c(1,2,3), constant = 1)
# Comparing to median
abs(y - median(pred_1)) / mad(pred_1, constant = 1)
abs(y - median(pred_2)) / mad(pred_2, constant = 1)
abs(y - median(pred_3)) / mad(pred_3, constant = 1)
# Squared = similar to weighted MSE
((y - median(pred_1)) / mad(pred_1, constant = 1))^2
((y - median(pred_2)) / mad(pred_2, constant = 1))^2
((y - median(pred_3)) / mad(pred_3, constant = 1))^2
y <- 4
set.seed(84735)
pred_1 <- rnorm(10000, mean = 0, sd = 1)
pred_2 <- rnorm(10000, mean = 10, sd = 3)
pred_3 <- rnorm(10000, mean = 10, sd = 6)
# Plot predictive models
dat <- data.frame(predictions = c(pred_1,pred_2,pred_3), model = rep(c("1","2","3"), each = 10000))
ggplot(dat, aes(x = predictions, fill = model)) +
geom_density(alpha = 0.5) +
geom_vline(xintercept = 4, color = "red")
# Plot residuals models
dat <- dat %>%
mutate(resids = y - predictions)
ggplot(dat, aes(x = resids, fill = model)) +
geom_density(alpha = 0.5) +
geom_vline(xintercept = 0)
# MSE for models 1, 2, & 3
(y - mean(pred_1))^2
(y - mean(pred_2))^2
(y - mean(pred_3))^2
# Weighted MSE for models 1, 2, & 3
(y - mean(pred_1))^2 / var(pred_1)
((y - mean(pred_1)) / sd(pred_1))^2
(y - mean(pred_2))^2 / var(pred_2)
(y - mean(pred_3))^2 / var(pred_3)
# calculate p(y|theta) at each theta in simulation
# i don't have p(y|theta).  pred_1 is y drawn from p(y|theta) from fake theta.
# draw theta
set.seed(1)
theta <- rnorm(1000)
pred_new <- rnorm(1000, mean = theta)
# like plot on p20 of gelman
hist(log(dnorm(y, mean = theta)))
# R scales the MAD.  Use constant = 1 to get raw
mad(c(1,2,3))
mad(c(1,2,3), constant = 1)
# Comparing to median
abs(y - median(pred_1)) / mad(pred_1)
abs(y - median(pred_2)) / mad(pred_2)
abs(y - median(pred_3)) / mad(pred_3)
# Squared = similar to weighted MSE
(abs(y - median(pred_1)) / mad(pred_1))^2
(abs(y - median(pred_2)) / mad(pred_2))^2
(abs(y - median(pred_3)) / mad(pred_3))^2
dic_fncn <- function(pred){
pdic <- 2*(log(dnorm(4, mean = mean(pred))) - mean(log(dnorm(4, mean = pred))))
-2*log(dnorm(4, mean = mean(pred))) + 2*pdic
}
dic_fncn(pred_1)
dic_fncn(pred_2)
dic_fncn(pred_3)
# This is consistent with http://kylehardman.com/BlogPosts/View/6
pred <- pred_1
L = log(dnorm(4,mean(pred)))
S = length(pred)
llSum = 0
for (s in 1:S) {
theta_s = pred[s]
llSum = llSum + log(dnorm(4,theta_s))
}
P = 2 * (L - (1 / S * llSum))
DIC = -2 * (L - P)
# RETURN: DIC measure for some future data and posterior predictive distribution based on theta model and prediction rule
# y: future data
# theta_model: posterior theta we choose based on past y
# bayes_predict: rule to choose theta_hat_bayesian from our posterior theta. Posterior mean by default
dic_fncn <- function(y, theta_model, bayes_predict = mean) {
theta_bayes = bayes_predict(theta_model)
pdic <- 2 * ( dnorm(y, mean = mean(theta_bayes), sd = 1, log = TRUE) - mean(dnorm(y, mean = theta_model, sd = 1, log = TRUE)) )
-2*dnorm(4, mean = mean(theta_bayes), sd = 1, log = TRUE) + 2*pdic
}
dic_fncn(pred_1)
dic_fncn(4, theta_model = theta_1, bayes_predict = mean())
dic_fncn(4, theta_model = theta_1, bayes_predict = mean)
dic_fncn(4, theta_model = theta_2, bayes_predict = mean)
dic_fncn(4, theta_model = theta_3, bayes_predict = mean)
dic_fncn(4, theta_model = theta_1, bayes_predict = median)
dic_fncn(4, theta_model = theta_2, bayes_predict = median)
dic_fncn(4, theta_model = theta_3, bayes_predict = median)
dic_fncn(4, theta_model = theta_1, bayes_predict = mean)
dic_fncn(4, theta_model = theta_2, bayes_predict = mean)
dic_fncn(4, theta_model = theta_3, bayes_predict = mean)
dic_fncn(4, theta_model = theta_1, bayes_predict = median)
dic_fncn(4, theta_model = theta_2, bayes_predict = median)
dic_fncn(4, theta_model = theta_3, bayes_predict = median)
pred <- pred_1
L = log(dnorm(4,mean(pred)))
S = length(pred)
llSum = 0
for (s in 1:S) {
theta_s = pred[s]
llSum = llSum + log(dnorm(4,theta_s))
}
P = 2 * (L - (1 / S * llSum))
DIC = -2 * (L - P)
DIC
install.packages("LaplacesDemon")
library(LaplacesDemon) # Too lazy to implement my own numerical mode approximation function
dic_fncn(4, theta_model = theta_1, bayes_predict = Mode)
dic_fncn <- function(y, theta_model, bayes_predict = mean) {
theta_bayes = bayes_predict(theta_model)
pdic <- 2 * ( dnorm(y, mean = theta_bayes, sd = 1, log = TRUE) - mean(dnorm(y, mean = theta_model, sd = 1, log = TRUE)) )
-2*dnorm(4, mean = theta_bayes, sd = 1, log = TRUE) + 2*pdic
}
dic_fncn(4, theta_model = theta_1, bayes_predict = mean)
dic_fncn(4, theta_model = theta_2, bayes_predict = mean)
dic_fncn(4, theta_model = theta_3, bayes_predict = mean)
dic_fncn(4, theta_model = theta_1, bayes_predict = median)
dic_fncn(4, theta_model = theta_2, bayes_predict = median)
dic_fncn(4, theta_model = theta_3, bayes_predict = median)
dic_fncn(4, theta_model = theta_1, bayes_predict = Mode)
Mode(theta_1)
mean(theta_1)
median(ttheta_1)
median(theta_1)
pred_1
